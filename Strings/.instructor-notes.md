# Mastering Strings in Java

## Introduction

Imagine you are a software engineer at a fintech startup, and you have been tasked with processing customer transactions. Your application needs to handle names, account numbers, transaction descriptions, and more. But here's the challenge: these are all **textual data**. How will you store and manipulate them efficiently?

Enter the **String** class in Java, the go-to solution for working with text. Strings are everywhere in Java applications—logging messages, processing user input, constructing dynamic reports, and even interacting with databases.

To master Java, you must understand Strings inside out. Let’s dive deep into the world of Java Strings!

---

## What is a String in Java?

In Java, a **String** is an immutable sequence of characters. It is an instance of the `String` class and is used to store and manipulate text.

### Key Characteristics of Strings:
- **Immutable**: Once created, a String cannot be changed.
- **Stored in String Pool**: Java optimizes memory usage by maintaining a pool of String literals.
- **Implements `CharSequence` Interface**: This allows Strings to work with other sequence-based classes like `StringBuilder` and `StringBuffer`.

### Creating Strings
Strings can be created in multiple ways:

#### 1. Using String Literals (Stored in the String Pool)
```jshelllanguage
String name = "Alice";
```
This method optimizes memory by storing the value in the **String Pool**.

#### 2. Using the `new` Keyword (Stored in the Heap)
```jshelllanguage
String name = new String("Alice");
```
This explicitly creates a new String object in the heap memory.

### Memory Optimization: String Literals vs `new` Keyword

Using **String literals** helps optimize memory because Java maintains a **String Pool** where identical string values are stored only once. Let’s illustrate this with a program:

```jshelllanguage
public class StringMemoryOptimization {
    public static void main(String[] args) {
        // String literals (stored in String Pool)
        String s1 = "Hello";
        String s2 = "Hello";
        
        // Using 'new' keyword (creates a new object in Heap Memory)
        String s3 = new String("Hello");
        String s4 = new String("Hello");
        
        // Comparing references
        System.out.println("s1 == s2: " + (s1 == s2)); // true (same object in String Pool)
        System.out.println("s3 == s4: " + (s3 == s4)); // false (different objects in Heap)
        System.out.println("s1 == s3: " + (s1 == s3)); // false (different memory locations)
        
        // Comparing actual values
        System.out.println("s1.equals(s3): " + s1.equals(s3)); // true (same content)
    }
}
```

**Output:**
```
s1 == s2: true
s3 == s4: false
s1 == s3: false
s1.equals(s3): true
```

### Explanation:
1. **String literals (`s1` and `s2`)**: Both refer to the same object in the String Pool.
2. **Strings created with `new` (`s3` and `s4`)**: Each instance is stored separately in heap memory, increasing memory usage.
3. **`.equals()` compares content**, while `==` compares references.

Thus, for memory efficiency, prefer **String literals** unless an explicit new instance is required.

---

## Understanding String Immutability

Let’s consider this example:
```jshelllanguage
String s1 = "Hello";
s1 = s1 + " World";
System.out.println(s1);
```
**Output:**
```
Hello World
```

Though it appears that `s1` has been modified, Java actually creates a new String object (`"Hello World"`) and `s1` now refers to this new object, leaving the original `"Hello"` unchanged.

**Why is immutability important?**
- Enhances **performance** by allowing String Pool optimization.
- Makes **multi-threading** safer since String objects cannot be changed unexpectedly.
- Allows **caching** and reuse, reducing memory overhead.

---

## Common String Operations

### 1. String Concatenation
Concatenation joins two strings together.
```jshelllanguage
String firstName = "John";
String lastName = "Doe";
String fullName = firstName + " " + lastName;
System.out.println(fullName);
```
**Output:**
```
John Doe
```

Alternatively, we can use `concat()`:
```jshelllanguage
String message = "Hello".concat(" World");
System.out.println(message);
```

### 2. String Length
```jshelllanguage
String text = "Java Programming";
System.out.println(text.length());
```
**Output:**
```
16
```

### 3. Accessing Characters
```jshelllanguage
String word = "Hello";
char firstChar = word.charAt(0);
System.out.println(firstChar);
```
**Output:**
```
H
```

### 4. Extracting Substrings
```jshelllanguage
String sentence = "Learn Java";
String sub = sentence.substring(6);
System.out.println(sub);
```
**Output:**
```
Java
```

### 5. String Comparison
```jshelllanguage
String s1 = "hello";
String s2 = "Hello";
System.out.println(s1.equals(s2));
System.out.println(s1.equalsIgnoreCase(s2));
```
**Output:**
```
false
true
```

### 6. Searching in Strings
```jshelllanguage
String data = "Java is powerful";
System.out.println(data.contains("Java"));
System.out.println(data.indexOf("power"));
```
**Output:**
```
true
8
```

### 7. Converting Case
```jshelllanguage
String text = "HeLLo";
System.out.println(text.toLowerCase());
System.out.println(text.toUpperCase());
```
**Output:**
```
hello
HELLO
```

---

```jshelllanguage
/*
* 1. Problem Statement
*
* This program demonstrates various String operations and methods in Java.
* It covers the following:
* - Creating Strings
* - String Concatenation
* - String Length
* - Character Extraction
* - Substring Operations
* - String Comparison
* - Searching within Strings
* - Case Conversion
* - String Splitting
* - Trimming Whitespaces
* - Replacing Characters/Substrings
*
* The program includes JUnit test cases to verify correctness.
  */

public class StringOperations {

    public static void main(String[] args) {
        // Creating Strings
        String literalString = "Hello, Java!";
        String newKeywordString = new String("Hello, Java!");

        // String Concatenation
        String concatenated = literalString + " Let's learn.";
        
        // String Length
        int length = literalString.length();
        
        // Character Extraction
        char firstChar = literalString.charAt(0);
        
        // Substring Extraction
        String substring = literalString.substring(7);
        
        // String Comparison
        boolean equalsCheck = literalString.equals(newKeywordString);
        boolean equalsIgnoreCaseCheck = "java".equalsIgnoreCase("JAVA");
        
        // Searching in Strings
        boolean containsJava = literalString.contains("Java");
        int indexOfJava = literalString.indexOf("Java");
        
        // Case Conversion
        String lowerCase = literalString.toLowerCase();
        String upperCase = literalString.toUpperCase();
        
        // Trimming Whitespaces
        String withSpaces = "  Trim me  ";
        String trimmed = withSpaces.trim();
        
        // String Splitting
        String csv = "apple,banana,grape";
        String[] fruits = csv.split(",");
        
        // String Replacement
        String replacedString = literalString.replace("Java", "World");
        
        // Displaying Results
        System.out.println("Concatenated: " + concatenated);
        System.out.println("Length: " + length);
        System.out.println("First Character: " + firstChar);
        System.out.println("Substring: " + substring);
        System.out.println("Equals Check: " + equalsCheck);
        System.out.println("Ignore Case Check: " + equalsIgnoreCaseCheck);
        System.out.println("Contains 'Java': " + containsJava);
        System.out.println("Index of 'Java': " + indexOfJava);
        System.out.println("Lower Case: " + lowerCase);
        System.out.println("Upper Case: " + upperCase);
        System.out.println("Trimmed: '" + trimmed + "'");
        System.out.println("Replaced: " + replacedString);
    }
}

/*
* 2. Expected Output
*
* Concatenated: Hello, Java! Let's learn.
* Length: 12
* First Character: H
* Substring: Java!
* Equals Check: true
* Ignore Case Check: true
* Contains 'Java': true
* Index of 'Java': 7
* Lower Case: hello, java!
* Upper Case: HELLO, JAVA!
* Trimmed: 'Trim me'
* Replaced: Hello, World!
  */

// JUnit Test Cases
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

public class StringOperationsTest {

    @Test
    void testConcatenation() {
        String result = "Hello, Java!" + " Let's learn.";
        assertEquals("Hello, Java! Let's learn.", result);
    }

    @Test
    void testLength() {
        assertEquals(12, "Hello, Java!".length());
    }

    @Test
    void testCharacterExtraction() {
        assertEquals('H', "Hello, Java!".charAt(0));
    }

    @Test
    void testSubstring() {
        assertEquals("Java!", "Hello, Java!".substring(7));
    }

    @Test
    void testStringComparison() {
        assertTrue("java".equalsIgnoreCase("JAVA"));
    }

    @Test
    void testSearching() {
        assertTrue("Hello, Java!".contains("Java"));
        assertEquals(7, "Hello, Java!".indexOf("Java"));
    }

    @Test
    void testCaseConversion() {
        assertEquals("hello, java!", "Hello, Java!".toLowerCase());
        assertEquals("HELLO, JAVA!", "Hello, Java!".toUpperCase());
    }

    @Test
    void testTrimming() {
        assertEquals("Trim me", "  Trim me  ".trim());
    }

    @Test
    void testStringReplacement() {
        assertEquals("Hello, World!", "Hello, Java!".replace("Java", "World"));
    }
}
```


## Conclusion
Strings are fundamental to Java programming. By understanding immutability, memory optimization, and common operations, you can write efficient and robust applications.

**Your next steps?** Implement the exercises above, experiment with `StringBuilder` for mutable strings, and explore advanced topics like regular expressions!

